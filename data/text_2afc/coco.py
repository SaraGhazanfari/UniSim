from os.path import join
import pandas as pd
from torch.utils.data import Dataset
import random
from PIL import Image


SCORE_TO_CAPTIONS_MAP = {
    'OFA': 'OFA_Huge',
    'GIT': 'GIT_Large',
    'Our': 'Ensemble',
    'ExpNet-v2': 'ExpansionNet_v2',
    'BLIP-2': 'BLIP_2',
    'ViT-GPT2': 'ViT_GPT2',
}

DEFAULT_DIRS = {
    'coco-images': 'coco/val2014',
    'coco-modelcaptions': 'resources/all_captions_extended.csv',
    'coco-expertscores': 'resources/expert_worker_results_extended.csv',
    'coco-genericscores': 'resources/generic_worker_results_extended.csv',
}


class CocoTriplets(Dataset):
    """
    Sample captions for COCO images generated by different models and scored by human
    annotators in https://arxiv.org/abs/2306.11593. The images are filtered out to
    retain only with unanimuous choice of the best caption (>=2/3).
    """

    name = 'coco-triplets'

    def __init__(self, data_dir, score_type, transform_fn=None,
                 min_score=2, sampling_mode='rand', verbose=False, text_processor=None, instruct=None):
        self.image_dir = join('/', DEFAULT_DIRS['coco-images'])
        self.captions = pd.read_csv(join(data_dir, CocoTriplets.name, DEFAULT_DIRS['coco-modelcaptions']))
        self.min_score = min_score
        self.scores = pd.read_csv(join(data_dir, CocoTriplets.name, DEFAULT_DIRS[score_type]))
        self.scores = self.scores[self.scores['max_score'] >= self.min_score
                                  ].reset_index(drop=True)
        self.transform_fn = transform_fn
        self.verbose = verbose
        self.sampling_mode = sampling_mode

        self.text_processor = text_processor
        self.instruct = instruct

        # Enumerate all triplets (different worse captions).
        self.all_triplets = []
        for _, row in self.scores.iterrows():
            i = 0
            for _, k in enumerate(SCORE_TO_CAPTIONS_MAP.keys()):
                if row[k] == 0:
                    self.all_triplets.append((row['Image_URL'], i))
                    i += 1
        

    def __getitem__(self, idx):

        if self.sampling_mode == 'rand':
            img_name = self.scores.loc[idx, 'Image_URL']
            img = Image.open(join(self.image_dir, img_name))
            if self.transform_fn:
                img = self.transform_fn(img)
            scores = {k: self.scores.loc[idx, k] for k in SCORE_TO_CAPTIONS_MAP.keys()}
            # Sample caption with highest score.
            methods = [k for k, v in scores.items() if v == max(scores.values())]
            method = random.choice(methods)
            better_cap = self.captions[self.captions['fname'] == img_name][
                SCORE_TO_CAPTIONS_MAP[method]].values[0]
            if self.verbose:
                print(method, scores[method], better_cap)
            # Sample caption with 0 score.
            methods = [k for k, v in scores.items() if v == 0]
            method = random.choice(methods)
            worse_cap = self.captions[self.captions['fname'] == img_name][
                SCORE_TO_CAPTIONS_MAP[method]].values[0]
            if self.verbose:
                print(method, scores[method], worse_cap)
        
        elif self.sampling_mode == 'all-zeros':
            img_name = self.all_triplets[idx][0]
            img = Image.open(join(self.image_dir, img_name))
            
            if self.transform_fn:
                img = self.transform_fn(img)
                
            orig_idx = self.scores.index[self.scores['Image_URL'] == img_name][0]
            scores = {k: self.scores.loc[orig_idx, k] for k in SCORE_TO_CAPTIONS_MAP.keys()}
            # Sample caption with highest score.
            methods = [k for k, v in scores.items() if v == max(scores.values())]
            method = random.choice(methods)
            better_cap = self.captions[self.captions['fname'] == img_name][
                SCORE_TO_CAPTIONS_MAP[method]].values[0]
            if self.verbose:
                print(method, scores[method], better_cap)
            # Get caption with 0 score (iterates over all).
            methods = [k for k, v in scores.items() if v == 0]
            method = methods[self.all_triplets[idx][1]]
            worse_cap = self.captions[self.captions['fname'] == img_name][
                SCORE_TO_CAPTIONS_MAP[method]].values[0]
            if self.verbose:
                print(method, scores[method], worse_cap)
        
        caps = [better_cap, worse_cap]
        random.shuffle(caps)
        lab = int(caps[1] == better_cap)
        if self.instruct:
            caps = [self.text_processor(self.instruct.format(cap1=caps[0], cap2=caps[1]))]
        
        return img, caps, lab

    def __len__(self):
        if self.sampling_mode == 'rand':
            return len(self.scores)
        elif self.sampling_mode == 'all-zeros':
            return len(self.all_triplets)

        
